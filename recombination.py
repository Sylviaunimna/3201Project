import random
import numpy
import math

def order_crossover(pop1, pop2):
    """
        Returns two lists filled with points generated by order crossover
        args:
            pop1: list
                  city indexes
            pop2: list
                  city indexes
            dists: Mulidimensional List
                   precalculated distance between all points on the graph
    """
    off1 = []
    off2 = []
    index = random.sample(range(1,len(pop1)-1),2)
    if index[0] > index[1]:
        index[0], index[1] = index[1], index[0]
    off1 = order_x(index[0], index[1], pop1, pop2)
    off2 = order_x(index[0], index[1], pop2, pop1)
    return off1, off2

def m_order(pop1, pop2, dists):
    """
        Returns two lists filled with points generated by Modified order crossover
        args:
            pop1: list
                  city indexes
            pop2: list
                  city indexes
            dists: Mulidimensional List
                   precalculated distance between all points on the graph
    """
    off1 = []
    off2 = []
    index = modified_order(pop2, dists)
    off1 = order_x(index[0], index[1], pop1, pop2)
    index = modified_order(pop1, dists)
    off2 = order_x(index[0], index[1], pop2, pop1)
    return off1, off2

def greedyCrossover(pop1, pop2):
    off1 = []
    off2 = []
    index = random.sample(range(0,len(pop1)),2)
    off1 = greedyX(pop1[index[0]], pop1, pop2)
    off2 = greedyX(pop2[index[1]], pop2, pop1)
    return off1, off2


def order_x(seg1, seg2, pop1, pop2):
    """
        Returns a list generated by order crossover
        args:
            seg1: index of first crossover point
                  city indexes
            seg2: index of second crossover point
                  city indexes
            pop1: list
                  city indexes
            pop2: list
                  city indexes
    """
    size = len(pop1)
    off = [None] * size
    for i in range(seg1, seg2+1):
        off[i] = pop1[i]
    i = seg2+1
    x = i
    while off[i] == None:
        while pop2[x] in off:
            x = (x+1)%size
            if pop2[x] not in off:
                break
        off[i] = pop2[x]
        i = (i+1)%size
        if off[i] != None:
            break
    return off

def modified_order(pop, dists):
    size = len(pop)-1
    mini = math.inf
    index = 0
    for i in range(size-1):
        dist = dists[pop[i]-1, pop[i+1]-1]
        if dist < mini:
            mini = dist
            seg1 = i
    seg2 = random.randrange(seg1,len(pop)-1)
    return [seg1, seg2]

def greedyX(num, pop1, pop2):
    off = []
    off.append(num)
    for j in range(len(pop1)-1):
        #off.append(num)
        p1_in = pop1.index(num)
        p2_in = pop2.index(num)
        p1_edges = getEdges(p1_in, len(pop1)-1)
        p2_edges = getEdges(p2_in, len(pop2)-1)
        edges = [pop1[p1_edges[0]], pop1[p1_edges[1]], pop2[p2_edges[0]], pop2[p2_edges[1]]]
        minim = min(edges)
        if minim in off:
                m = len(pop1)
                not_in_off = random.choice([pop1[x] for x in range(m) if pop1[x] not in off])                
                num = not_in_off

        else:
            num = minim
        off.append(num)
            
    return off

def getEdges(index, max_index):
    edges = []
    if index == 0:
        edges.append(max_index)
        edges.append(index+1)
    elif index == max_index:
        edges.append(index-1)
        edges.append(0)
    else:
        edges.append(index-1)
        edges.append(index+1)
    return edges

    
        
    
    
    
